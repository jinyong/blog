# 六原则
## 1. 单一职责原则
单一职责所表达的是"高内聚"。所谓高内聚就是一个代码模块只完成一项功能。

## 2. 开闭原则
当需要增加新功能时，只需从原来的系统派生出一些新类，而不需修改原来的任何一行代码。  
要做到开闭原则有两个要点：1. 抽象约束 2. 封装变化。  
将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而乱。
### 2.1 开闭原则的作用
#### 2.1.1 对软件测试的影响
软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
#### 2.1.2 可以提高代码的可复用性
粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
#### 2.1.3 可以提高软件的可维护性
遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

## 3. 依赖倒转原则：面向接口编程
依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。
### 3.1 依赖倒置原则的作用
#### 3.1.1 依赖倒置原则可以降低类间的耦合性。
#### 3.1.2 依赖倒置原则可以提高系统的稳定性。
#### 3.1.3 依赖倒置原则可以减少并行开发引起的风险。
#### 3.1.4 依赖倒置原则可以提高代码的可读性和可维护性。
### 3.2 依赖倒置原则的实现方法
依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。  
1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。
### 3.3 例：“顾客购物程序”
分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：
```
class Customer
{
    public void shopping(ShaoguanShop shop)
    {
        //购物
        System.out.println（shop.sell());
    }
}
````
但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：
```
class Customer
{
    public void shopping(WuyuanShop shop)
    {
        //购物
        System.out.println(shop.sell());
    }
}
```
顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：
```
class Customer
{
    public void shopping(Shop shop)
    {
        //购物
        System.out.println(shop.sell());
    }
}
```
这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示。
#### 图1
![Image text](http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif)
#### 程序代码
```
package principle;
public class DIPtest
{
    public static void main(String[] args)
    {
        Customer wang=new Customer();
        System.out.println("顾客购买以下商品："); 
        wang.shopping(new ShaoguanShop()); 
        wang.shopping(new WuyuanShop());
    }
}
//商店
interface Shop
{
    public String sell(); //卖
}
//韶关网店
class ShaoguanShop implements Shop
{
    public String sell()
    {
        return "韶关土特产：香菇、木耳……"; 
    } 
}
//婺源网店
class WuyuanShop implements Shop
{
    public String sell()
    {
        return "婺源土特产：绿茶、酒糟鱼……"; 
    }
} 
//顾客
class Customer
{
    public void shopping(Shop shop)
    {
        //购物
        System.out.println(shop.sell()); 
    }
}
```
#### 程序运行结果
```
顾客购买以下商品：
韶关土特产：香菇、木耳……
婺源土特产：绿茶、酒糟鱼……
```

## 4. 里氏替换原则：任何时候都可以用子类替换掉父类
里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。  
能用父类型的地方就一定能用子类型。里氏替换原则可以检查继承关系是否合理，如果一个集成关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。
### 4.1 里氏替换原则的作用
#### 4.1.1 里氏替换原则是实现开闭原则的重要方式之一。
#### 4.1.2 它克服了继承中重写父类造成的可复用性变差的缺点。
#### 4.1.3 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
### 4.2 里氏替换原则的实现方法
里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。

关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。
#### 4.2.1 例：“几维鸟不是鸟”
分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 1 所示。
##### 图1
![Image text](http://c.biancheng.net/uploads/allimg/181113/3-1Q11311094H32.gif)
##### 程序代码
```
package principle;
public class LSPtest
{
    public static void main(String[] args)
    {
        Bird bird1=new Swallow();
        Bird bird2=new BrownKiwi();
        bird1.setSpeed(120);
        bird2.setSpeed(120);
        System.out.println("如果飞行300公里：");
        try
        {
            System.out.println("燕子将飞行"+bird1.getFlyTime(300)+"小时.");
            System.out.println("几维鸟将飞行"+bird2.getFlyTime(300)+"小时。");
        }
        catch(Exception err)
        {
            System.out.println("发生错误了!");
        }
    }
}
//鸟类
class Bird
{
    double flySpeed;
    public void setSpeed(double speed)
    {
        flySpeed=speed;
    }
    public double getFlyTime(double distance)
    {
        return(distance/flySpeed);
    }
}
//燕子类
class Swallow extends Bird{}
//几维鸟类
class BrownKiwi extends Bird
{
    public void setSpeed(double speed)
    {
           flySpeed=0;
    }
}
```
##### 程序运行结果
```
如果飞行300公里：
燕子将飞行2.5小时.
几维鸟将飞行Infinity小时。
```

程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 2 所示。
##### 图2
![Image text](http://c.biancheng.net/uploads/allimg/181113/3-1Q11311101SN.gif)

## 5. 接口隔离原则
臃肿的接口是对接口的污染，接口也应该是高内聚。Java中的接口代表能力，代表约定，代表角色，能否正确使用接口是编程水平高低的重要表示。

## 6. 合成聚合复用原则：优先使用聚合或合成关系复用代码
通过集成复用代码是面向对象设计中被滥用的最多的东西。任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。

# 迪米特法则
迪米特法则简单讲就是如何做到“低耦合”。门面模式和调停者模式就是对迪米特法则的践行。更通俗的讲，它就是不要和陌生人打交道，如果真需要，找一个自己的朋友，让他替你合陌生人打交道。

# 参考
> [https://blog.csdn.net/myuhua/article/details/81562759](https://blog.csdn.net/myuhua/article/details/81562759)

> [软件设计模式概述](http://c.biancheng.net/view/1317.html)
